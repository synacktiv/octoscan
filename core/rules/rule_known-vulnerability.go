/*
	Rule based on https://github.com/boostsecurityio/poutine/blob/main/opa/rego/rules/known_vulnerability_in_build_component.rego
	Check for known vulnerabilities
*/

package rules

import (
	_ "embed"
	"strings"

	"github.com/google/osv-scanner/pkg/models"
	"github.com/hashicorp/go-version"
	"github.com/rhysd/actionlint"
)

type RuleKnownVulnerability struct {
	actionlint.RuleBase
	filterTriggers []string
	skip           bool
}

var (
	//go:embed assets/ghsa.json
	GHSAJson            []byte
	GHSAVulnerabilities []models.Vulnerability
)

// NewRuleKnownVulnerability creates new RuleKnownVulnerability instance.
func NewRuleKnownVulnerability(filterTriggers []string) *RuleKnownVulnerability {
	return &RuleKnownVulnerability{
		RuleBase: actionlint.NewRuleBase(
			"known-vulnerability",
			"Check for known vulnerabilities.",
		),
		filterTriggers: filterTriggers,
		skip:           false,
	}
}

func (rule *RuleKnownVulnerability) VisitWorkflowPre(n *actionlint.Workflow) error {
	// check on event and set skip if needed
	rule.skip = skipAnalysis(n, rule.filterTriggers)

	return nil
}

// VisitStep is callback when visiting Step node.
func (rule *RuleKnownVulnerability) VisitStep(n *actionlint.Step) error {
	if rule.skip {
		return nil
	}

	e, ok := n.Exec.(*actionlint.ExecAction)
	if !ok || e.Uses == nil {
		return nil
	}

	if e.Uses.ContainsExpression() {
		// Cannot parse specification made with interpolation. Give up
		return nil
	}

	spec := e.Uses.Value
	rule.checkForKnownVulnerabilities(spec, e)

	return nil
}

func (rule *RuleKnownVulnerability) checkForKnownVulnerabilities(spec string, exec *actionlint.ExecAction) {
	// Parse {owner}/{repo}@{ref} or {owner}/{repo}/{path}@{ref}
	s := spec
	idx := strings.IndexRune(s, '@')

	if idx == -1 {
		return
	}

	ref := s[idx+1:]

	if !strings.HasPrefix(ref, "v") {
		return
	}

	// we loop over all the vulnerabilities in assets/ghsa.json
	for _, vulnerability := range GHSAVulnerabilities {
		// for each vulnerability we loop over the affected actions
		for _, affected := range vulnerability.Affected {
			if strings.HasPrefix(spec, affected.Package.Name) {
				// we loop over the ranges
				for _, vulnRange := range affected.Ranges {
					// we build the constraint string for hashicorp/go-version
					currentVersion, _ := version.NewVersion(ref)
					constraintStr := ""

					// not sure about this
					constraintStr += ">=" + vulnRange.Events[0].Introduced
					constraintStr += ","
					constraintStr += "<" + vulnRange.Events[1].Fixed

					// we check if our version is in the constraint range
					constraint, _ := version.NewConstraint(constraintStr)
					if constraint.Check(currentVersion) {
						// we don't trigger a vuln if the ref don't contains dot, we assume that if v4.1.2 is vulnerable v4 will be patched
						if !(!strings.Contains(ref, ".") && strings.Contains(vulnRange.Events[1].Fixed, ".")) {
							rule.RuleBase.Errorf(
								exec.Uses.Pos,
								"The action %q in version %q is vulnerable. See %q",
								spec,
								ref,
								vulnerability.ID,
							)
						}
					}
				}
			}
		}
	}
}
